/* 
 * This file is part of the UnixCommons distribution (https://github.com/yoori/unixcommons).
 * UnixCommons contains help classes and functions for Unix Server application writing
 *
 * Copyright (c) 2012 Yuri Kuznecov <yuri.kuznecov@gmail.com>.
 * 
 * This program is free software: you can redistribute it and/or modify  
 * it under the terms of the GNU General Public License as published by  
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */



#include "Tests.hpp"
#include <HTTP/HttpTestCommons/ApachePorts.hpp>

//
// General constants
//

char hostname[HOST_NAME_MAX];
const int hostname_res = gethostname(hostname, sizeof(hostname));
const HTTP::HttpServer SERVER(hostname, ApachePorts::get_port(34));
const std::string REQUEST = std::string("http://") + SERVER.first + ':'
  + ApachePorts::get_port_string(34);

//
// EchoTest
//

//
// EchoTest Constants
//

const std::string ECHO_GET_STRING =
  "app=PS&v=1.3.0-3.ssv1&tid=108&rnd=388334&"
  "xinfopsid=0&format=html&require-debug-info="
  "body&glbfcap=0&referer=act.com";
const std::string ECHO_POST_STRING =
  "login=Petya%20Vasechkin&password=qq";

const std::string GET_RESPONSE_BEGIN = "<BODY>\n";
const std::string GET_RESPONSE_END = "\n</BODY>";

const std::string ECHO_GET_REQUEST = REQUEST + "/cgi-bin/echo.pl?" + ECHO_GET_STRING;
const std::string ECHO_POST_REQUEST = REQUEST + "/cgi-bin/echo.pl";

const char echo_test_name[] = "EchoTest";

const char*
EchoTest::usage() throw()
{
  return "[EchoTest]\n"
         "1. Sends GET and POST requests one after another to server\n"
         "   (response is generated by echo.pl script, which puts\n"
         "    query params (GET) or content (POST) into the body).\n"
         "2. on_response callback checks up body accordance to what\n"
         "   was sent.\n"
         "3. It is expected, that all requests were successfully added,\n"
         "   that all responses were got and that all checks were succeeded.\n";
}

//
// class EchoTest
//

EchoTest::EchoTest(Sync::Semaphore& finish_semaphore,
  HTTP::HttpInterface* pool, unsigned int test_duration,
  unsigned int making_requests_duration, unsigned int tasks_per_test,
  unsigned int functors_per_task, bool log_needed) throw (eh::Exception):
    CTTestInterface(pool, test_duration, making_requests_duration,
                    tasks_per_test, functors_per_task),
    log_needed_(log_needed)
{
  my_cb_ = new CheckUpCallback(HTTP::PoolPolicy_var(new SimplePolicy).in(),
    ECHO_GET_STRING, ECHO_POST_STRING, GET_RESPONSE_BEGIN, GET_RESPONSE_END);
  HTTP::ResponseCallback_var proxy(new CallBackProxy(finish_semaphore,
    my_cb_));
  requester_.reset(new Requester(*this, pool_.in(), proxy, ECHO_GET_REQUEST,
    ECHO_POST_REQUEST, ECHO_POST_STRING));
}

std::string
EchoTest::checkup_and_print_stat() throw (eh::Exception)
{
  if (stat_.str().empty())
  {
    if (!is_error(echo_test_name, &requester_->get_counter(), &my_cb_->get_counter(),
         &my_cb_->get_checkup_counter()) && !my_cb_->get_counter().succeeded())
    {
      std::cerr << "[ERROR] " << echo_test_name << " failed. Description: "
                << "There are no succeeded requests ( "
                << my_cb_->get_counter().succeeded() << " succeeded and "
                << my_cb_->get_counter().failed() << " failed )" << std::endl;
    }

    stat_ << echo_test_name << " statistics:\n";
    requester_->print_stat(stat_);
    my_cb_->print_stat(stat_);
    my_cb_->print_errors(stat_, log_needed_);
  }

  return stat_.str();
}

EchoTest::~EchoTest() throw ()
{
}

//
// NonExistanceTest
//

//
// NonExistanceTest Constants
//

const std::string UNREQUITED_REQ = REQUEST + "/cgi-bin/nonexistant.pl";
const char nonexistance_test_name[] = "NonexistanceTest";

const char*
NonExistanceTest::usage() throw()
{
  return "[NonExistanceTest]\n"
         "1. Sends GET and POST requests one after another to server\n"
         "   (response \"Not Found\" is generated by apache (nonexistant.pl\n"
         "    script must not exists)).\n"
         "2. It is expected, that all requests were successfully added,\n"
         "   and that all responses were got.\n";
}

//
// class NonExistanceTest
//

NonExistanceTest::NonExistanceTest(Sync::Semaphore& finish_semaphore,
     HTTP::HttpInterface* pool, unsigned int test_duration,
     unsigned int making_requests_duration, unsigned int tasks_per_test,
     unsigned int functors_per_task, bool log_needed)
  throw (eh::Exception):
    CTTestInterface(pool, test_duration, making_requests_duration,
                    tasks_per_test, functors_per_task),
    log_needed_(log_needed)
{
  my_cb_ = new SimpleCounterCallback(
    HTTP::PoolPolicy_var(new SimplePolicy).in());
  HTTP::ResponseCallback_var proxy(new CallBackProxy(finish_semaphore,
    my_cb_));
  requester_.reset(new Requester(*this, pool_.in(), proxy,
    UNREQUITED_REQ, UNREQUITED_REQ));
}

std::string
NonExistanceTest::checkup_and_print_stat() throw (eh::Exception)
{
  if (stat_.str().empty())
  {
    if (!is_error(nonexistance_test_name, &requester_->get_counter(), &my_cb_->get_counter(), 0)
        && (!my_cb_->get_counter().succeeded() || my_cb_->get_counter().failed()))
    {
      std::cerr << "[ERROR] " << nonexistance_test_name << " failed. Description: "
                << "There are no succeeded requests or at least one failed request exists ( "
                << my_cb_->get_counter().succeeded() << " succeeded and "
                << my_cb_->get_counter().failed() << " failed )" << std::endl;
    }

    stat_ << nonexistance_test_name << " statistics:\n";
    requester_->print_stat(stat_);
    my_cb_->print_stat(stat_);
    my_cb_->print_errors(stat_, log_needed_);
  }

  return stat_.str();
}

NonExistanceTest::~NonExistanceTest() throw ()
{
}

//
// BadAddressTest
//

//
// BadAddressTest Constants
//

const std::string BAD_REQ = std::string("http://") + SERVER.first +
  ":65493/cgi-bin/nonexistant.pl";
const char bad_address_test_name[] = "BadAddressTest";

const char*
BadAddressTest::usage() throw()
{
  return "[BadAddressTest]\n"
         "1. Sends GET and POST requests one after another to server,\n"
         "   that is not started (Port 65593).\n"
         "2. It is expected, that all requests were successfully added,\n"
         "   that all responses were NOT got.\n";
}

//
// class BadAddressTest
//

BadAddressTest::BadAddressTest(Sync::Semaphore& finish_semaphore,
  HTTP::HttpInterface* pool, unsigned int test_duration,
  unsigned int making_requests_duration, unsigned int tasks_per_test,
  unsigned int functors_per_task, bool log_needed)
  throw (eh::Exception):
    CTTestInterface(pool, test_duration, making_requests_duration,
                    tasks_per_test, functors_per_task),
    log_needed_(log_needed)
{
  my_cb_ = new SimpleCounterCallback(
    HTTP::PoolPolicy_var(new SimplePolicy).in());
  HTTP::ResponseCallback_var proxy(new CallBackProxy(finish_semaphore,
    my_cb_));
  requester_.reset(new Requester(*this, pool_.in(), proxy,
    BAD_REQ, BAD_REQ));
}

std::string
BadAddressTest::checkup_and_print_stat() throw (eh::Exception)
{
  if (stat_.str().empty())
  {
    if (!is_error(bad_address_test_name, &requester_->get_counter(), &my_cb_->get_counter(), 0)
        && (my_cb_->get_counter().succeeded() || !my_cb_->get_counter().failed()))
    {
      std::cerr << "[ERROR] " << bad_address_test_name << " failed. Description: "
                << "There are no failed request or at least one succeeded request exists ( "
                << my_cb_->get_counter().succeeded() << " succeeded and "
                << my_cb_->get_counter().failed() << " failed )" << std::endl;
    }

    stat_ << bad_address_test_name << " statistics:\n";
    requester_->print_stat(stat_);
    my_cb_->print_stat(stat_);
    my_cb_->print_errors(stat_, log_needed_);
  }

  return stat_.str();
}

BadAddressTest::~BadAddressTest() throw ()
{
}

//
// InterruptTest
//

//
// InterruptTest Constants
//

const std::string INTERRUPT_REQ = std::string("http://") + SERVER.first +
  ':' + ApachePorts::get_port_string(31) + "/cgi-bin/interrupt.pl";
const char interrupt_test_name[] = "InterruptTest";

const char*
InterruptTest::usage() throw()
{
  return "[InterruptTest]\n"
         "1. Sends GET and POST requests one after another to server\n"
         "   (response is generated by interrupt.pl script, which stops\n"
         "    the server when the first request with param value more\n"
         "    then 50 is got).\n"
         "2. It is expected, that all requests were successfully added\n"
         "   and that more than 51 responses were got successfully.\n";
}

//
// class InterruptCallback
//

InterruptCallback::InterruptCallback(HTTP::PoolPolicy* policy,
    Sync::Semaphore& sem) throw(eh::Exception):
  SimpleCounterCallback(policy),
  sem_(sem),
  cnt_(0)
{
}

InterruptCallback::~InterruptCallback() throw()
{
}

void
InterruptCallback::on_response(const HTTP::ResponseInformation& data) throw ()
{
  check();
  SimpleCounterCallback::on_response(data);
}

void
InterruptCallback::on_error(const String::SubString& description,
  const HTTP::RequestInformation& data) throw ()
{
  check();
  SimpleCounterCallback::on_error(description, data);
}

inline
void
InterruptCallback::check() throw()
{
  if (cnt_ >= 50)
  {
    sem_.release();
    cnt_ = -1;
  }
  else
  {
    ++cnt_;
  }
}

//
// class InterruptTest
//

InterruptTest::InterruptTest(Sync::Semaphore& finish_semaphore,
  HTTP::HttpInterface* pool, unsigned int test_duration,
  unsigned int making_requests_duration, unsigned int tasks_per_test,
  unsigned int functors_per_task, bool log_needed)
  throw (eh::Exception):
    CTTestInterface(pool, test_duration, making_requests_duration,
                    tasks_per_test, functors_per_task),
    log_needed_(log_needed),
    sem_(0)
{
  counter_ = 0;

  char *p = getenv("TEST_TMP_DIR");
  tmp_dir = p ? p : "../../../test/tmp";

  my_cb_ = new InterruptCallback(
    HTTP::PoolPolicy_var(new SimplePolicy).in(), sem_);
  HTTP::ResponseCallback_var proxy(new CallBackProxy(finish_semaphore,
    my_cb_));
  requester_.reset(new Requester(*this, pool_.in(), proxy,
    INTERRUPT_REQ, INTERRUPT_REQ));
}

const std::string
InterruptTest::additional_http_query() throw (eh::Exception)
{
  Sync::PosixGuard guard(mutex_);
  if (counter_ == 51)
  {
    sem_.acquire();
  }
  std::ostringstream ostr;
  ostr << '?' << tmp_dir << ":" << counter_++;
  return ostr.str();
};

std::string
InterruptTest::checkup_and_print_stat() throw (eh::Exception)
{
  if (stat_.str().empty())
  {
    if (!is_error(interrupt_test_name, &requester_->get_counter(), &my_cb_->get_counter(), 0)
        && (my_cb_->get_counter().succeeded() < 51 || 
            my_cb_->get_counter().failed() < my_cb_->get_counter().succeeded()))
    {
      std::cerr << "[ERROR] " << interrupt_test_name << " failed. Description: "
                << "There are at least 51 successful requests should be present "
                   "(more, than half of all requests should be failed requests), "
                   "but we have "
                << my_cb_->get_counter().succeeded() << " succeeded and "
                << my_cb_->get_counter().failed() << " failed" << std::endl;
    }

    stat_ << interrupt_test_name << " statistics:\n";
    requester_->print_stat(stat_);
    my_cb_->print_stat(stat_);
    my_cb_->print_errors(stat_, log_needed_);
  }

  return stat_.str();
}

InterruptTest::~InterruptTest() throw ()
{
}

//
// BadRespTest
//

//
// BadRespTest Constants
//

const std::string BAD_RESP_REQ = REQUEST + "/cgi-bin/bad_resp.pl";
const char bad_response_test_name[] = "BadResponseTest";

const char*
BadRespTest::usage() throw()
{
  return "[BadRespTest]\n"
         "1. Sends GET and POST requests one after another to server\n"
         "   (response is generated by bad_resp.pl script, which begin\n"
         "    to write invalid response headers when the request with\n"
         "    param value more then 50 is got).\n"
         "2. It is expected, that all requests were successfully added\n"
         "   and that all responses were got successfully.\n";
}

//
// class BadRespTest
//

BadRespTest::BadRespTest(Sync::Semaphore& finish_semaphore,
  HTTP::HttpInterface* pool, unsigned int test_duration,
  unsigned int making_requests_duration, unsigned int tasks_per_test,
  unsigned int functors_per_task, bool log_needed)
  throw (eh::Exception):
    CTTestInterface(pool, test_duration, making_requests_duration,
                    tasks_per_test, functors_per_task),
    log_needed_(log_needed)
{
  counter_ = 0;

  my_cb_ = new SimpleCounterCallback(
    HTTP::PoolPolicy_var(new SimplePolicy).in());
  HTTP::ResponseCallback_var proxy(new CallBackProxy(finish_semaphore,
    my_cb_));
  requester_.reset(new Requester(*this, pool_.in(), proxy,
    BAD_RESP_REQ, BAD_RESP_REQ));
}

const std::string
BadRespTest::additional_http_query() throw (eh::Exception)
{
  std::ostringstream ostr;
  ostr << '?';
  {
    Sync::PosixGuard guard(mutex_);
    ostr << counter_++;
  }
  return ostr.str();
}

std::string
BadRespTest::checkup_and_print_stat() throw (eh::Exception)
{
  if (stat_.str().empty())
  {
    if (!is_error(nonexistance_test_name, &requester_->get_counter(), &my_cb_->get_counter(), 0)
        && (!my_cb_->get_counter().succeeded() || my_cb_->get_counter().failed()))
    {
      std::cerr << "[ERROR] " << bad_response_test_name << " failed. Description: "
                << "There are no succeeded requests or at least one failed request exists ( "
                << my_cb_->get_counter().succeeded() << " succeeded and "
                << my_cb_->get_counter().failed() << " failed )" << std::endl;
    }

    stat_ << bad_response_test_name << " statistics:\n";
    requester_->print_stat(stat_);
    my_cb_->print_stat(stat_);
    my_cb_->print_errors(stat_, log_needed_);
  }

  return stat_.str();
}

BadRespTest::~BadRespTest() throw ()
{
}
